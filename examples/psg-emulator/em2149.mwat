{@
  $.X = 2;
}
{@struct CHANNEL
  i32 vol[3];
}
{@struct PSG 
    (;; Volume Table ;;)
    i32 voltbl[64] = [ 0 , 0b0000_0001, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07, 0x09,
   0x0B, 0x0D, 0x0F, 0x12, 0x16, 0x1A, 0x1F, 0x25, 0x2D, 0x35, 0x3F, 0x4C,
   0x5A, 0x6A, 0x7F, 0x97, 0xB4, 0xD6, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x01,
   0x02, 0x02, 0x03, 0x03, 0x05, 0x05, 0x07, 0x07, 0x0B, 0x0B, 0x0F, 0x0F,
   0x16, 0x16, 0x1F, 0x1F, 0x2D, 0x2D, 0x3F, 0x3F, 0x5A, 0x5A, 0x7F, 0x7F,
   0xB4, 0xB4, 0xFF, 0xFF];
    i32 reg[0x20];
    i32 out = 2;

    i32 clk, rate, base_incr, quality;

    i32 count[3];
    i32 volume[3];
    i32 freq[3];
    i32 edge[3];
    i32 tmask[3];
    i32 nmask[3];
    i32 mask;

    i32 base_count;

    i32 env_volume;
    i32 env_ptr;
    i32 env_face;

    i32 env_continue;
    i32 env_attack;
    i32 env_alternate;
    i32 env_hold;
    i32 env_pause;
    i32 env_reset;

    i32 env_freq;
    i32 env_count;

    i32 noise_seed;
    i32 noise_count;
    i32 noise_freq;

    (;; rate converter ;;)
    i32 realstep;
    i32 psgtime;
    i32 psgstep;
    CHANNEL ch_c;

    (;; I/O Ctrl ;;)
    i32 adr;

    (;; output of channels ;;)
    i32 ch_out[3];
}


(module
  (memory $memory 1 
{@map
  PSG psg;
  i32 OutputBuffer[1024];
}
  
  )
  (export "memory" (memory $memory))
  (export "test" (func $test))
  (func $test (result i32)
    (i32.load (i32.const &psg.ch_c.vol[1] + X*4;))
    i32.const 1
    i32.add 
  )
)
